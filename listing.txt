1. Scanner 
	  - Fakes and Mocks. 
		- Behavior Verification
		- Most of the methods of a mock implementation do nothing or just store values in local 	
			collections.
			
		References: 
		
		Working Effectively with Legacy Code
		Unit Testing with Mock Objects
		
2. UnCommenter 
		- Illustrates using Ruby builtin StringIO as a Fake object.
 		- State Verification
	  
	 Reference: The Well Grounded Rubyist

3. Canonical 
		- Canonical test structure practice for Given, When, Then.
		- State Verification

4. Meszaros 
		- How to eliminate loops in specs. Data driven spec and repeat methods are
 	    available in meszaros gem.
		- How do we choose what data to test? 0, 1 and n
		- One to Many

5. Ruby Extensions 
		- How to open classes that preserves the semantics of the core classes.
	 	- What to do when the test passes without failing the first time.
		- Intention revealing variable names.
		- Minimizing the semantic gap between domain and the code.
		- Semantic Gap. Self evident, Obvious, Self-Explanatory. Donâ€™t Make Me Think.
		- State Verification

6. Angry Rock
		- How to fix Command Query Separation violation?
		- Refactoring : Retaining the old interface and the new one at the same time to avoid old
		  tests from failing
    - Semantic quirkiness of Well Grounded Rubyist solution exposed by specs.
		- Hiding implementation related classes. (AngryRock::Internal module)

7. Tautology
		- How to mock yourself out.

8. Rock 
	  - Rock, paper, scissors game
    - How to use double dispatch and make your code object oriented.
		- Exercise: Replace angry rock gem internal implementation with the double dispatch solution.

9. Fibonacci
		- Common interview question
		- Learn recursive solution and optimize the execution by using non-recursive solution
		- Focus on getting it to work first, cleanup by refactoring and then focus on optimization
		- When refactoring, start green and end in green
		- Using existing tests as regression tests when making major changes to existing code.
		- State Verification
		
10. Factorial
	 	- Factorial and Fibonacci demo screencast
		- Factorial and Fibonacci are example for : Examples --> Specs --> Requirements slide. 
		- Illustrates Direct Input and Direct Output.
		- State Verification
		
11. Bowling Game
		- Demo screencast
		- Using domain specific term and eliminating implementation details in the spec.
		- Focus on the 'What' instead of 'How'. Declarative vs Imperative.
		- Fake it till you make it.
		- Do you always need to take small steps when writing tests?
		- State Verification
		
12. Role
		- Being minimal when implementing the production code.

13. Bowling Game Gem
	  - miss() method implementation helped to setup the require statements and get the spec working.
		- When to delete tests?
		- Private methods are not tested. Why?
		
TODO:

1. Realistic example of Open Closed Principle
2. Triangulation. Example. Maybe 
3. Contract tests. How to write? When to use them?
4. Calculator kata	
5. Guilded rose Kata. Dealing with legacy code.
6. ? video game kata. Code retreat exercise.
7. Dealing with third party API. Braintree example. Illustrate learning tests which become
	 regression tests. Thin adapter layer to insulate your application from external API.
8. Example of brittle test that breaks even when the behavior does not change. How to fix it?
9. Using too many mocks and stubs and what it implies about the design.
10. Passing flag into a method and how to fix it.
11. Single responsibility principle. No And, Or, or But.
12. Testing logic via UI and how to fix it.



